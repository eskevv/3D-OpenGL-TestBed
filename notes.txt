Day 3
-------
* Vsyncing = glfwSwapInterval(1)

* stride indicates how many bytes to move to the next attribute
    of the SAME TPYE (e.g. the next position)

* glDrawElements will fill in missing indeces with 0's

* fragments are just pixels and the rasterization stage determines the
    color of each fragment based on interpolation around the initial colors
    and the closeness to each vertex.

CODE=
static ShaderProgramSource parseShader(const std::string& filePath) {
   std::ifstream stream(filePath);

   enum class ShaderType { NONE = -1, VERTEX = 0, FRAGMENT = 1 };

   std::string line{};
   std::stringstream ss[2]{};

   ShaderType type = ShaderType::NONE;

   while (getline(stream, line)) {
      if (line.find("#shader") != std::string::npos) {
         if (line.find("vertex") != std::string::npos) {
            type = ShaderType::VERTEX;
         } else if (line.find("fragment") != std::string::npos) {
            type = ShaderType::FRAGMENT;
         }
      } else {
         ss[(int)type] << line << '\n';
      }
   }

   return {ss[0].str(), ss[1].str()};
}

unsigned int compileShader(unsigned int type, const std::string& source) {
   unsigned int output = glReturn(glCreateShader(type));
   const char* src = source.c_str();
   glCall(glShaderSource(output, 1, &src, nullptr));
   glCall(glCompileShader(output));

   int success{};
   glCall(glGetShaderiv(output, GL_COMPILE_STATUS, &success));

   if (success == GL_FALSE) {
      int infoLength;
      glCall(glGetShaderiv(output, GL_INFO_LOG_LENGTH, &infoLength));
      char infoLog[infoLength];
      glCall(glGetShaderInfoLog(output, infoLength, &infoLength, infoLog));
      std::cout << "ERROR::SHADER::COMPILATION_FAILED" << (type == GL_VERTEX_SHADER ? ":VERTEX." : ":FRAGMENT ") << infoLog << std::endl;
      glCall(glDeleteShader(output));
      return 0;
   }

   return output;
}

static unsigned int createShader(const std::string& vertex, const std::string& fragment) {
   unsigned int shaderProgram = glReturn(glCreateProgram());

   unsigned int vs = compileShader(GL_VERTEX_SHADER, vertex);
   unsigned int fs = compileShader(GL_FRAGMENT_SHADER, fragment);

   glCall(glAttachShader(shaderProgram, vs));
   glCall(glAttachShader(shaderProgram, fs));
   glCall(glLinkProgram(shaderProgram));
   glCall(glValidateProgram(shaderProgram));
   glCall(glDeleteShader(vs));
   glCall(glDeleteShader(fs));
   return shaderProgram;
}